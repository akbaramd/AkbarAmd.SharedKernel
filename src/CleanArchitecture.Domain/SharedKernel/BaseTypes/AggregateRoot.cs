using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using CleanArchitecture.Domain.SeedWork;
using CleanArchitecture.Domain.SharedKernel.Events;

namespace CleanArchitecture.Domain.SharedKernel.BaseTypes
{
    /// <summary>
    /// Base class for Aggregate Roots in Domain-Driven Design.
    /// Supports identity, domain event tracking, versioning, snapshotting, and state tracking.
    /// Implements best practices for concurrency, event management, and infrastructure integration.
    /// </summary>
    /// <typeparam name="TId">Type of the AggregateRoot's identity (usually Guid, int, string, etc.)</typeparam>
    public abstract class AggregateRoot<TId> : EntityBase<TId>, IAggregateRoot
        where TId : IEquatable<TId>
    {
        private readonly List<IDomainEvent> _domainEvents = new();
        private readonly ReaderWriterLockSlim _domainEventsLock = new(LockRecursionPolicy.SupportsRecursion);

        /// <summary>
        /// Version for optimistic concurrency control.
        /// Incremented on each committed state change.
        /// </summary>
         private long _version;  // backing field for Version

        public long Version => _version; // public readonly property

        /// <summary>
        /// Optional snapshot version, useful for event sourcing or caching.
        /// </summary>
        public long SnapshotVersion { get; protected set; }

        /// <summary>
        /// Timestamp of last modification (UTC).
        /// </summary>
        public DateTimeOffset LastModifiedUtc { get; private set; }

        /// <summary>
        /// Indicates whether the aggregate root has pending domain events.
        /// </summary>
        public bool HasPendingEvents
        {
            get
            {
                _domainEventsLock.EnterReadLock();
                try
                {
                    return _domainEvents.Count > 0;
                }
                finally
                {
                    _domainEventsLock.ExitReadLock();
                }
            }
        }

        /// <summary>
        /// Read-only collection of domain events generated by this aggregate root.
        /// Thread-safe snapshot copy.
        /// </summary>
        public IReadOnlyCollection<IDomainEvent> DomainEvents
        {
            get
            {
                _domainEventsLock.EnterReadLock();
                try
                {
                    return _domainEvents.ToList().AsReadOnly();
                }
                finally
                {
                    _domainEventsLock.ExitReadLock();
                }
            }
        }

        /// <summary>
        /// Creates a new aggregate root instance with the specified id.
        /// </summary>
        protected AggregateRoot(TId id) : base(id)
        {
            LastModifiedUtc = DateTimeOffset.UtcNow;
            _version = 1;
        }

        /// <summary>
        /// Protected parameterless constructor for ORM/ODM.
        /// </summary>
        protected AggregateRoot() : base()
        {
            LastModifiedUtc = DateTimeOffset.UtcNow;
            _version = 1;
        }

        /// <summary>
        /// Registers a new domain event for this aggregate.
        /// Thread-safe.
        /// </summary>
        /// <param name="domainEvent">The domain event to add</param>
        protected void AddDomainEvent(IDomainEvent domainEvent)
        {
            if (domainEvent == null) throw new ArgumentNullException(nameof(domainEvent));

            _domainEventsLock.EnterWriteLock();
            try
            {
                _domainEvents.Add(domainEvent);
            }
            finally
            {
                _domainEventsLock.ExitWriteLock();
            }
        }

        /// <summary>
        /// Clears all domain events from this aggregate.
        /// Thread-safe.
        /// </summary>
        public void ClearDomainEvents()
        {
            _domainEventsLock.EnterWriteLock();
            try
            {
                _domainEvents.Clear();
            }
            finally
            {
                _domainEventsLock.ExitWriteLock();
            }
        }

        /// <summary>
        /// Apply a state change and raise a domain event.
        /// Template method to enforce consistent event raising.
        /// </summary>
        /// <typeparam name="TEvent">Domain event type</typeparam>
        /// <param name="domainEvent">Domain event instance</param>
        /// <param name="stateChanger">Action to apply state changes</param>
        protected void RaiseEvent<TEvent>(TEvent domainEvent, Action<TEvent> stateChanger)
            where TEvent : IDomainEvent
        {
            if (domainEvent == null) throw new ArgumentNullException(nameof(domainEvent));
            if (stateChanger == null) throw new ArgumentNullException(nameof(stateChanger));

            // Apply state changes first
            stateChanger(domainEvent);

            // Track the domain event
            AddDomainEvent(domainEvent);

            // Update modification time
            LastModifiedUtc = DateTimeOffset.UtcNow;
        }

        /// <summary>
        /// Create a snapshot representing current state.
        /// Override for event-sourced aggregates.
        /// </summary>
        /// <returns>Snapshot object</returns>
        public virtual object CreateSnapshot() => null;

        /// <summary>
        /// Restore aggregate state from snapshot.
        /// Override for event-sourced aggregates.
        /// </summary>
        /// <param name="snapshot">Snapshot object</param>
        public virtual void RestoreFromSnapshot(object snapshot) { }

        /// <summary>
        /// Called after rehydrating aggregate from events or snapshot.
        /// Resets transient state.
        /// </summary>
        public virtual void OnRehydrated()
        {
            ClearDomainEvents();
        }

        /// <summary>
        /// Increment version after successful commit.
        /// Thread-safe.
        /// </summary>
        public void IncrementVersion()
        {
            Interlocked.Increment(ref _version);
            LastModifiedUtc = DateTimeOffset.UtcNow;
        }

        #region Equality & Hashcode overrides (based on Id and type)

        public override bool Equals(object obj)
        {
            if (obj is null) return false;
            if (ReferenceEquals(this, obj)) return true;

            if (obj.GetType() != GetType()) return false;

            if (obj is not AggregateRoot<TId> other) return false;

            return Id.Equals(other.Id);
        }

        public override int GetHashCode() => HashCode.Combine(GetType(), Id);

        public static bool operator ==(AggregateRoot<TId> left, AggregateRoot<TId> right)
        {
            if (ReferenceEquals(left, null)) return ReferenceEquals(right, null);
            return left.Equals(right);
        }

        public static bool operator !=(AggregateRoot<TId> left, AggregateRoot<TId> right) => !(left == right);

        #endregion

        /// <summary>
        /// String representation for debugging and logging.
        /// </summary>
        public override string ToString() => $"{GetType().Name} [Id={Id}, Version={Version}]";
    }
}
