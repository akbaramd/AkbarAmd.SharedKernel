/*
 * Developed by Akbar Ahmadi Saray
 * Clean Architecture Domain Shared Kernel - Base Types
 * AggregateRoot base class supporting identity, domain events, versioning, snapshotting, and concurrency.
 * Year: 2025
 */

using MCA.SharedKernel.Domain.Contracts;
using MCA.SharedKernel.Domain.Events;

namespace MCA.SharedKernel.Domain
{
    /// <summary>
    /// Base class for Aggregate Roots in Domain-Driven Design.
    /// Implements core aggregate functionality with hierarchical audit capabilities.
    /// Supports identity, domain event tracking, versioning, snapshotting, and state tracking.
    /// Implements best practices for concurrency, event management, and infrastructure integration.
    /// Designed to work seamlessly with Entity Framework Core.
    /// This class is designed to be globally applicable across all bounded contexts.
    /// </summary>
    /// <typeparam name="TId">Type of the AggregateRoot's identity (usually Guid, int, string, etc.)</typeparam>
    public abstract class AggregateRoot<TId> : Entity<TId>, 
        IAggregateRoot<TId>, 
        IFullyAuditableAggregateRoot
        where TId : IEquatable<TId>
    {
        #region Private Fields

        private readonly List<IDomainEvent> _domainEvents = new();
        private readonly ReaderWriterLockSlim _domainEventsLock = new(LockRecursionPolicy.SupportsRecursion);
        private long _version;  // backing field for Version

        #endregion

        #region IAggregateRoot Implementation

        /// <summary>
        /// Indicates whether the aggregate root has pending domain events.
        /// Thread-safe property for checking event state.
        /// </summary>
        public bool HasPendingEvents
        {
            get
            {
                _domainEventsLock.EnterReadLock();
                try
                {
                    return _domainEvents.Count > 0;
                }
                finally
                {
                    _domainEventsLock.ExitReadLock();
                }
            }
        }

        /// <summary>
        /// Read-only collection of domain events generated by this aggregate root.
        /// Thread-safe snapshot copy.
        /// </summary>
        public IReadOnlyCollection<IDomainEvent> DomainEvents
        {
            get
            {
                _domainEventsLock.EnterReadLock();
                try
                {
                    return _domainEvents.ToList().AsReadOnly();
                }
                finally
                {
                    _domainEventsLock.ExitReadLock();
                }
            }
        }

        /// <summary>
        /// Clears all domain events from this aggregate.
        /// Thread-safe operation.
        /// </summary>
        public void ClearDomainEvents()
        {
            _domainEventsLock.EnterWriteLock();
            try
            {
                _domainEvents.Clear();
            }
            finally
            {
                _domainEventsLock.ExitWriteLock();
            }
        }

        #endregion

        #region IVersionableAggregateRoot Implementation

        /// <summary>
        /// Version for optimistic concurrency control.
        /// Incremented on each committed state change.
        /// </summary>
        public long Version => _version;

        /// <summary>
        /// Optional snapshot version, useful for event sourcing or caching.
        /// </summary>
        public long SnapshotVersion { get; protected set; }

        /// <summary>
        /// Increment version after successful commit.
        /// Thread-safe operation for concurrency control.
        /// </summary>
        public void IncrementVersion()
        {
            Interlocked.Increment(ref _version);
            LastModifiedUtc = DateTimeOffset.UtcNow;
        }

        /// <summary>
        /// Create a snapshot representing current state.
        /// Override in derived classes for event-sourced aggregates.
        /// </summary>
        /// <returns>Snapshot object or null if not implemented.</returns>
        public virtual object CreateSnapshot() => null;

        /// <summary>
        /// Restore aggregate state from snapshot.
        /// Override in derived classes for event-sourced aggregates.
        /// </summary>
        /// <param name="snapshot">Snapshot object to restore from.</param>
        public virtual void RestoreFromSnapshot(object snapshot) { }

        /// <summary>
        /// Called after rehydrating aggregate from events or snapshot.
        /// Resets transient state and clears domain events.
        /// </summary>
        public virtual void OnRehydrated()
        {
            ClearDomainEvents();
        }

        #endregion

        #region ICreatableAggregateRoot Implementation

        /// <summary>
        /// UTC timestamp when the aggregate was created.
        /// </summary>
        public DateTime CreatedAt { get; private set; }

        /// <summary>
        /// Identifier of the user/system that created the aggregate.
        /// </summary>
        public string CreatedBy { get; private set; }

        /// <summary>
        /// UTC timestamp when the aggregate was created (UTC).
        /// </summary>
        public DateTimeOffset CreatedAtUtc { get; private set; }

        #endregion

        #region IModifiableAggregateRoot Implementation

        /// <summary>
        /// UTC timestamp when the aggregate was last modified.
        /// </summary>
        public DateTime? ModifiedAt { get; private set; }

        /// <summary>
        /// Identifier of the user/system that last modified the aggregate.
        /// </summary>
        public string? ModifiedBy { get; private set; }

        /// <summary>
        /// UTC timestamp of last modification (UTC).
        /// </summary>
        public DateTimeOffset LastModifiedUtc { get; private set; }

        /// <summary>
        /// Marks the aggregate as modified, updating timestamps.
        /// </summary>
        /// <param name="modifiedBy">Identifier of the user/system making the modification.</param>
        public void MarkModified(string modifiedBy)
        {
            ModifiedAt = DateTime.UtcNow;
            ModifiedBy = modifiedBy ?? throw new ArgumentNullException(nameof(modifiedBy));
            LastModifiedUtc = DateTimeOffset.UtcNow;
        }

        #endregion

        #region IDeletableAggregateRoot Implementation

        /// <summary>
        /// UTC timestamp when the aggregate was soft deleted.
        /// </summary>
        public DateTime? DeletedAt { get; private set; }

        /// <summary>
        /// Identifier of the user/system that deleted the aggregate.
        /// </summary>
        public string? DeletedBy { get; private set; }

        /// <summary>
        /// Indicates whether the aggregate has been soft deleted.
        /// </summary>
        public bool IsDeleted { get; private set; }

        /// <summary>
        /// Soft deletes the aggregate by setting IsDeleted to true.
        /// </summary>
        /// <param name="deletedBy">Identifier of the user/system performing the deletion.</param>
        public void Delete(string deletedBy)
        {
            if (IsDeleted) return;

            IsDeleted = true;
            DeletedAt = DateTime.UtcNow;
            DeletedBy = deletedBy ?? throw new ArgumentNullException(nameof(deletedBy));
            MarkModified(deletedBy);
        }

        /// <summary>
        /// Restores a soft-deleted aggregate by setting IsDeleted to false.
        /// </summary>
        /// <param name="restoredBy">Identifier of the user/system performing the restoration.</param>
        public void Restore(string restoredBy)
        {
            if (!IsDeleted) return;

            IsDeleted = false;
            DeletedAt = null;
            DeletedBy = null;
            MarkModified(restoredBy ?? throw new ArgumentNullException(nameof(restoredBy)));
        }

        #endregion

        #region IMetadataAggregateRoot Implementation

        /// <summary>
        /// Optional metadata associated with the aggregate.
        /// </summary>
        public string? Metadata { get; private set; }

        /// <summary>
        /// Updates the aggregate's metadata and marks it as modified.
        /// </summary>
        /// <param name="metadata">The new metadata value.</param>
        /// <param name="modifiedBy">Identifier of the user/system making the change.</param>
        public void UpdateMetadata(string metadata, string modifiedBy)
        {
            Metadata = metadata ?? throw new ArgumentNullException(nameof(metadata));
            MarkModified(modifiedBy ?? throw new ArgumentNullException(nameof(modifiedBy)));
        }

        #endregion

        #region IFullyAuditableAggregateRoot Additional Implementation

        /// <summary>
        /// UTC timestamp when the aggregate was last accessed (read).
        /// </summary>
        public DateTime? LastAccessedAt { get; private set; }

        /// <summary>
        /// Identifier of the user/system that last accessed the aggregate.
        /// </summary>
        public string? LastAccessedBy { get; private set; }

        /// <summary>
        /// Number of times the aggregate has been accessed.
        /// </summary>
        public long AccessCount { get; private set; }

        /// <summary>
        /// UTC timestamp when the aggregate was last backed up.
        /// </summary>
        public DateTime? LastBackupAt { get; private set; }

        /// <summary>
        /// UTC timestamp when the aggregate was last archived.
        /// </summary>
        public DateTime? LastArchivedAt { get; private set; }

        /// <summary>
        /// Marks the aggregate as accessed.
        /// </summary>
        /// <param name="accessedBy">Identifier of the user/system accessing the aggregate.</param>
        public virtual void MarkAccessed(string accessedBy)
        {
            LastAccessedAt = DateTime.UtcNow;
            LastAccessedBy = accessedBy ?? throw new ArgumentNullException(nameof(accessedBy));
            AccessCount++;
        }

        /// <summary>
        /// Marks the aggregate as backed up.
        /// </summary>
        public virtual void MarkBackedUp()
        {
            LastBackupAt = DateTime.UtcNow;
        }

        /// <summary>
        /// Marks the aggregate as archived.
        /// </summary>
        public virtual void MarkArchived()
        {
            LastArchivedAt = DateTime.UtcNow;
            MarkModified("system");
        }

        #endregion

        #region Constructors

        /// <summary>
        /// Creates a new aggregate root instance with the specified id.
        /// This constructor is used when creating new aggregates with a known ID.
        /// </summary>
        /// <param name="id">The aggregate's unique identifier.</param>
        protected AggregateRoot(TId id) : base(id)
        {
            var now = DateTime.UtcNow;
            var nowUtc = DateTimeOffset.UtcNow;
            
            CreatedAt = now;
            CreatedBy = "system";
            CreatedAtUtc = nowUtc;
            LastModifiedUtc = nowUtc;
            _version = 1;
            IsDeleted = false;
            AccessCount = 0;
        }

        /// <summary>
        /// Creates a new aggregate root instance with the specified id and creator.
        /// This constructor is used when creating new aggregates with a known ID and creator.
        /// </summary>
        /// <param name="id">The aggregate's unique identifier.</param>
        /// <param name="createdBy">Identifier of the creator.</param>
        protected AggregateRoot(TId id, string createdBy) : base(id)
        {
            var now = DateTime.UtcNow;
            var nowUtc = DateTimeOffset.UtcNow;
            
            CreatedAt = now;
            CreatedBy = createdBy ?? throw new ArgumentNullException(nameof(createdBy));
            CreatedAtUtc = nowUtc;
            LastModifiedUtc = nowUtc;
            _version = 1;
            IsDeleted = false;
            AccessCount = 0;
        }

        /// <summary>
        /// Protected parameterless constructor for ORM/ODM support.
        /// This constructor is required by Entity Framework Core for materialization.
        /// The ID and other properties will be set by EF Core during materialization.
        /// </summary>
        protected AggregateRoot()
        {
            var now = DateTime.UtcNow;
            var nowUtc = DateTimeOffset.UtcNow;
            
            CreatedAt = now;
            CreatedBy = "system";
            CreatedAtUtc = nowUtc;
            LastModifiedUtc = nowUtc;
            _version = 1;
            IsDeleted = false;
            AccessCount = 0;
        }

        #endregion

        #region Domain Event Management

        /// <summary>
        /// Registers a new domain event for this aggregate.
        /// Thread-safe operation.
        /// </summary>
        /// <param name="domainEvent">The domain event to add.</param>
        /// <exception cref="ArgumentNullException">Thrown when domainEvent is null.</exception>
        protected void AddDomainEvent(IDomainEvent domainEvent)
        {
            if (domainEvent == null) throw new ArgumentNullException(nameof(domainEvent));

            _domainEventsLock.EnterWriteLock();
            try
            {
                _domainEvents.Add(domainEvent);
            }
            finally
            {
                _domainEventsLock.ExitWriteLock();
            }
        }

        /// <summary>
        /// Apply a state change and raise a domain event.
        /// Template method to enforce consistent event raising.
        /// </summary>
        /// <typeparam name="TEvent">Domain event type.</typeparam>
        /// <param name="domainEvent">Domain event instance.</param>
        /// <param name="stateChanger">Action to apply state changes.</param>
        /// <exception cref="ArgumentNullException">Thrown when domainEvent or stateChanger is null.</exception>
        protected void RaiseEvent<TEvent>(TEvent domainEvent, Action<TEvent> stateChanger)
            where TEvent : IDomainEvent
        {
            if (domainEvent == null) throw new ArgumentNullException(nameof(domainEvent));
            if (stateChanger == null) throw new ArgumentNullException(nameof(stateChanger));

            // Apply state changes first
            stateChanger(domainEvent);

            // Track the domain event
            AddDomainEvent(domainEvent);

            // Update modification time
            MarkModified("system");
        }

        #endregion

        #region String Representation

        /// <summary>
        /// String representation for debugging and logging.
        /// </summary>
        /// <returns>A string that represents the current aggregate root.</returns>
        public override string ToString() => $"{GetType().Name} [Id={Id}, Version={Version}, IsDeleted={IsDeleted}, AccessCount={AccessCount}]";

        #endregion
    }
}
