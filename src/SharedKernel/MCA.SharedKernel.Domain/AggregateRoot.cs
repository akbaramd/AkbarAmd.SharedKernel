/*
 * Developed by Akbar Ahmadi Saray
 * Clean Architecture Domain Shared Kernel - Base Types
 * AggregateRoot base class supporting identity, domain events, versioning, snapshotting, and concurrency.
 * Year: 2025
 */

using MCA.SharedKernel.Domain.Contracts;
using MCA.SharedKernel.Domain.Events;

namespace MCA.SharedKernel.Domain
{
    /// <summary>
    /// Base class for Aggregate Roots in Domain-Driven Design.
    /// Supports identity, domain event tracking, versioning, snapshotting, and state tracking.
    /// Implements best practices for concurrency, event management, and infrastructure integration.
    /// This class is designed to be globally applicable across all bounded contexts.
    /// </summary>
    /// <typeparam name="TId">Type of the AggregateRoot's identity (usually Guid, int, string, etc.)</typeparam>
    public abstract class AggregateRoot<TId> : AuditableEntity<TId>, IAggregateRoot<TId>, IAggregateRoot
        where TId : IEquatable<TId>
    {
        #region Private Fields

        private readonly List<IDomainEvent> _domainEvents = new();
        private readonly ReaderWriterLockSlim _domainEventsLock = new(LockRecursionPolicy.SupportsRecursion);
        private long _version;  // backing field for Version

        #endregion

        #region IAggregateRoot Implementation

        /// <summary>
        /// Version for optimistic concurrency control.
        /// Incremented on each committed state change.
        /// </summary>
        public new long Version => _version;

        /// <summary>
        /// Optional snapshot version, useful for event sourcing or caching.
        /// </summary>
        public long SnapshotVersion { get; protected set; }

        /// <summary>
        /// Timestamp of last modification (UTC).
        /// </summary>
        public DateTimeOffset LastModifiedUtc { get; private set; }

        /// <summary>
        /// Indicates whether the aggregate root has pending domain events.
        /// Thread-safe property for checking event state.
        /// </summary>
        public bool HasPendingEvents
        {
            get
            {
                _domainEventsLock.EnterReadLock();
                try
                {
                    return _domainEvents.Count > 0;
                }
                finally
                {
                    _domainEventsLock.ExitReadLock();
                }
            }
        }

        /// <summary>
        /// Read-only collection of domain events generated by this aggregate root.
        /// Thread-safe snapshot copy.
        /// </summary>
        public IReadOnlyCollection<IDomainEvent> DomainEvents
        {
            get
            {
                _domainEventsLock.EnterReadLock();
                try
                {
                    return _domainEvents.ToList().AsReadOnly();
                }
                finally
                {
                    _domainEventsLock.ExitReadLock();
                }
            }
        }

        #endregion

        #region Constructors

        /// <summary>
        /// Creates a new aggregate root instance with the specified id.
        /// </summary>
        /// <param name="id">The aggregate's unique identifier.</param>
        protected AggregateRoot(TId id) : base(id)
        {
            LastModifiedUtc = DateTimeOffset.UtcNow;
            _version = 1;
        }

        /// <summary>
        /// Creates a new aggregate root instance with the specified id and creator.
        /// </summary>
        /// <param name="id">The aggregate's unique identifier.</param>
        /// <param name="createdBy">Identifier of the creator.</param>
        protected AggregateRoot(TId id, string createdBy) : base(id, createdBy)
        {
            LastModifiedUtc = DateTimeOffset.UtcNow;
            _version = 1;
        }

        /// <summary>
        /// Protected parameterless constructor for ORM/ODM support.
        /// Should only be used by infrastructure components.
        /// </summary>
        protected AggregateRoot()
        {
            LastModifiedUtc = DateTimeOffset.UtcNow;
            _version = 1;
        }

        #endregion

        #region Domain Event Management

        /// <summary>
        /// Registers a new domain event for this aggregate.
        /// Thread-safe operation.
        /// </summary>
        /// <param name="domainEvent">The domain event to add.</param>
        /// <exception cref="ArgumentNullException">Thrown when domainEvent is null.</exception>
        protected void AddDomainEvent(IDomainEvent domainEvent)
        {
            if (domainEvent == null) throw new ArgumentNullException(nameof(domainEvent));

            _domainEventsLock.EnterWriteLock();
            try
            {
                _domainEvents.Add(domainEvent);
            }
            finally
            {
                _domainEventsLock.ExitWriteLock();
            }
        }

        /// <summary>
        /// Clears all domain events from this aggregate.
        /// Thread-safe operation.
        /// </summary>
        public void ClearDomainEvents()
        {
            _domainEventsLock.EnterWriteLock();
            try
            {
                _domainEvents.Clear();
            }
            finally
            {
                _domainEventsLock.ExitWriteLock();
            }
        }

        /// <summary>
        /// Apply a state change and raise a domain event.
        /// Template method to enforce consistent event raising.
        /// </summary>
        /// <typeparam name="TEvent">Domain event type.</typeparam>
        /// <param name="domainEvent">Domain event instance.</param>
        /// <param name="stateChanger">Action to apply state changes.</param>
        /// <exception cref="ArgumentNullException">Thrown when domainEvent or stateChanger is null.</exception>
        protected void RaiseEvent<TEvent>(TEvent domainEvent, Action<TEvent> stateChanger)
            where TEvent : IDomainEvent
        {
            if (domainEvent == null) throw new ArgumentNullException(nameof(domainEvent));
            if (stateChanger == null) throw new ArgumentNullException(nameof(stateChanger));

            // Apply state changes first
            stateChanger(domainEvent);

            // Track the domain event
            AddDomainEvent(domainEvent);

            // Update modification time
            LastModifiedUtc = DateTimeOffset.UtcNow;
        }

        #endregion

        #region Snapshot Management

        /// <summary>
        /// Create a snapshot representing current state.
        /// Override in derived classes for event-sourced aggregates.
        /// </summary>
        /// <returns>Snapshot object or null if not implemented.</returns>
        public virtual object CreateSnapshot() => null;

        /// <summary>
        /// Restore aggregate state from snapshot.
        /// Override in derived classes for event-sourced aggregates.
        /// </summary>
        /// <param name="snapshot">Snapshot object to restore from.</param>
        public virtual void RestoreFromSnapshot(object snapshot) { }

        /// <summary>
        /// Called after rehydrating aggregate from events or snapshot.
        /// Resets transient state and clears domain events.
        /// </summary>
        public virtual void OnRehydrated()
        {
            ClearDomainEvents();
        }

        #endregion

        #region Version Management

        /// <summary>
        /// Increment version after successful commit.
        /// Thread-safe operation for concurrency control.
        /// </summary>
        public void IncrementVersion()
        {
            Interlocked.Increment(ref _version);
            LastModifiedUtc = DateTimeOffset.UtcNow;
        }

        #endregion

        #region Equality and Comparison

        /// <summary>
        /// Determines whether the specified object is equal to the current aggregate root.
        /// </summary>
        /// <param name="obj">The object to compare with the current aggregate root.</param>
        /// <returns>True if the specified object is equal to the current aggregate root; otherwise, false.</returns>
        public override bool Equals(object? obj)
        {
            if (obj is null) return false;
            if (ReferenceEquals(this, obj)) return true;

            if (obj.GetType() != GetType()) return false;

            if (obj is not AggregateRoot<TId> other) return false;

            return Id.Equals(other.Id);
        }

        /// <summary>
        /// Serves as the default hash function.
        /// </summary>
        /// <returns>A hash code for the current aggregate root.</returns>
        public override int GetHashCode() => HashCode.Combine(GetType(), Id);

        /// <summary>
        /// Equality operator for aggregate roots.
        /// </summary>
        /// <param name="left">Left aggregate root.</param>
        /// <param name="right">Right aggregate root.</param>
        /// <returns>True if aggregate roots are equal; otherwise, false.</returns>
        public static bool operator ==(AggregateRoot<TId>? left, AggregateRoot<TId>? right)
        {
            if (ReferenceEquals(left, null)) return ReferenceEquals(right, null);
            return left.Equals(right);
        }

        /// <summary>
        /// Inequality operator for aggregate roots.
        /// </summary>
        /// <param name="left">Left aggregate root.</param>
        /// <param name="right">Right aggregate root.</param>
        /// <returns>True if aggregate roots are not equal; otherwise, false.</returns>
        public static bool operator !=(AggregateRoot<TId>? left, AggregateRoot<TId>? right) => !(left == right);

        #endregion

        #region String Representation

        /// <summary>
        /// String representation for debugging and logging.
        /// </summary>
        /// <returns>A string that represents the current aggregate root.</returns>
        public override string ToString() => $"{GetType().Name} [Id={Id}, Version={Version}]";

        #endregion
    }
}
